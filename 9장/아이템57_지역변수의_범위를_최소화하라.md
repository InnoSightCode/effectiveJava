## 들어가기 전에
#### 자바 프로그램을 실행한다는 의미
- 자바 프로그램이란, 'javac' 컴파일러로 컴파일된 코드의 집합 (.class, .jar 형태)
- 자바 프로그램은 'java'라는 실행파일로 실행할 수 있음
- 'java'로 컴파일된 코드를 실행 -> 서버에 프로세스 형태로 자바 프로그램이 실행됨

#### 왜 jvm 프로세스라고 부를까?
- c언어랑 비교해보자.
    - C 소스코드를 `gcc` 컴파일러로 컴파일하면 기계어코드(실행파일)로 변환
    - 서버에서 이 실행파일을 실행하면, OS가 프로세스를 만들고 CPU는 기계어를 직접 실행
    - 따라서 C 프로그램은 곧바로 OS 프로세스로 뜸
- 하지만 java언어는 다르다
    - java 소스코드를 `javac` 컴파일러로 컴파일하면 바이트코드(.class)로 변환
    - 서버에서 컴파일 결과(.class/.jar)를 실행시키면? CPU는 바이트코드를 해석하지 못하기 때문에 동작 수행 불가
    - 서버에서 컴파일 결과(.class/.jar)를 실행시키려면, 바이트코드를 읽어 기계어로 해석/변환해 주는 자바 가상머신이 필요
    - 서버에서 `java` 명령으로 실행하면 OS에는 단순히 java 프로세스가 보이지만, 실제로 그 안에서는 JVM이 구동되어 바이트코드를 실행
    - 따라서, 자바 세계에서는 흔히 JVM 프로세스가 떴다 라고 표현

#### jvm의 역할?
- 바이트코드를 런타임에 기계어로 번역 (인터프리터와 JIT 컴파일러)
- 메모리 관리 : Heap, Stack, Metaspace, PC Register
- 가비지 컬렉션 : 메모리 자동 회수
- 스레드 및 동시성 지원
- 플랫폼 독립성 제공 : WORA
- 런타임 서비스 : 리플렉션 API 지원 등..
<BR>

## 변수의 종류
<img width="1566" height="602" alt="Image" src="https://github.com/user-attachments/assets/a064702e-883a-430d-abd7-ad3dae827d04" />

#### 1. 지역변수 (Local Variable)
- 선언위치 : 메서드, 생성자, 블록 안
- 생명주기 : 블록이 실행되는 동안만 존재, 블록 종료 시 소멸 (스택 프레임에서 사라짐)
- 초기화 필요성 : 반드시 개발자가 초기화 해야 함. (안하면 컴파일 에러)
- 스레드 안정성 : 각 스레드의 스택에 따로 존재하므로 기본적으로 thread-safe
```java
void process() {
    int count = 0; // 지역 변수
    for (int i = 0; i < 10; i++) {
        String temp = "data" + i; // 블록 안에서만 살아있음
    }
}
```

#### 2. 매개변수 (Paramater Variable)
- 선언위치 : 메서드/생성자의 괄호 안
- 생명주기 : 메서드가 실행되는 동안 (지역변수와 비슷)
- 초기화 필요성 : 호출 시점에 값이 전달되어 자동 초기화
- 스레드 안정성 : 각 스레드의 스택에 따로 존재하므로 기본적으로 thread-safe
```java
void printMessage(String message) { // 매개변수
    System.out.println(message);
}
```

#### 3. 인스턴스변수 (Instnce Variable, 멤버 변수)
- 선언위치 : 클래스 내부, 메서드 밖
- 생명주기 : 객체가 GC로 제거될 때까지 존재 (Heap 메모리)
- 초기화 필요성 : 안 하면 타입 기본값으로 자동 초기화 됨 (int -> 0, boolean -> false, 객체 -> null)
- 스레드 안정성 : 여러 스레드가 동시에 같은 객체의 인스턴스 변수에 접근하면 동기화 필요
```java
class Order {
    private int quantity; // 인스턴스 변수
}
```

#### 4. 전역변수 (Global Variable)? => 클래스변수 (Static Variable)
전역변수란, C나 Python 같은 언어에서 사용되는 용어로, 프로그램 전체 어디서나 접근 가능한 변수를 말한다. 
자바에서는 전역 변수가 없다. 대신 static 변수를 전역처럼 사용할 수 있다.
- 선언위치 : 클래스 내부, static 키워드를 붙임
- 생명주기 : 클래스 로딩 시 생성, JVM 종료까지 존재
- 초기화 필요성 : 안 하면 타입 기본값으로 자동 초기화 됨 (int -> 0, boolean -> false, 객체 -> null)
- 스레드 안정성 : 여러 스레드가 공유 -> 동시성 문제에 주의해야 함
```java
class Config {
    static final String SYSTEM_NAME = "Logistics"; // 클래스 변수
}
```

#### 📊 비교 요약
```java
public class VariableExample {

    // ✅ 클래스 변수 (전역 변수처럼 동작) : 모든 객체가 공유
    // JVM 종료 전까지 살아있음
    private static int globalVariable = 100;

    // ✅ 인스턴스 변수 : 객체마다 따로 존재
    // 객체가 GC될 때까지 살아있음
    private String instaceVariable;
    
    public void test(String parameterVariable) { // ✅ 매개변수
        // ✅ 지역 변수: 메서드 안에서 선언, 해당 블록 안에서만 유효
        String localVariable = "안녕하세요, " + parameterVariable;
    }
}

```

| 종류      | 선언 위치            | 메모리   | 생명주기        | 초기화 필요 여부 | 공유 범위        |
| ------- | ---------------- | ----- | ----------- | --------- | ------------ |
| 지역 변수   | 메서드/블록 내부        | 스택    | 블록 실행 중     | ✅ 직접 초기화  | 스레드별 독립      |
| 매개변수    | 메서드/생성자 선언부      | 스택    | 메서드 실행 중    | ❌ 자동 초기화  | 스레드별 독립      |
| 인스턴스 변수 | 클래스 내부, 메서드 외부   | 힙     | 객체가 살아있는 동안 | ❌ 기본값 초기화 | 객체 단위 공유     |
| 클래스 변수  | 클래스 내부, 메서드 외부, `static` | 메서드영역 | JVM 종료까지    | ❌ 기본값 초기화 | 모든 객체/스레드 공유 |

<BR>

## 지역변수의 범위를 최소화하라
지역변수의 유효 범위를 최소로 줄이면, 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.

#### 1. 지역변수는 '가장 처음 쓰일 때' 선언하라
C와 같이 역사 깊은 프로그래밍 언어 중에는 지역변수를 코드 블록의 첫 머리에 선언하는 경우가 많고, 이 방식을 여전히 습관처럼 따르는 프로그래머들이 있다.
하지만, 지역변수를 미리 선언해두면 코드가 어수선해져 가독성이 떨어지고, 변수를 실제 사용하는 시점엔 타입과 초깃값이 기억나지 않을 수도 있다.
```java
// Bad Case
void processUsers(List<String> users) {
    int size;                // 나중에 쓰일 변수를 먼저 선언해둠
    Iterator<String> it;     // 실제 사용까지 거리가 멀어 가독성 떨어짐

    // ... 많은 코드들 ...
    System.out.println("유저 처리 시작");

    size = users.size();
    it = users.iterator();
    while (it.hasNext()) {
        System.out.println(it.next());
    }
}

```
```java
// Good Case
void processUsers(List<String> users) {
    System.out.println("유저 처리 시작");

    int size = users.size();                   // 사용 직전에 선언과 초기화
    Iterator<String> it = users.iterator();    // 선언과 동시에 초기화
    while (it.hasNext()) {
        System.out.println(it.next());
    }
}

```

#### 2. 지역변수는 선언과 동시에 초기화해라
초기화에 필요한 정보가 충분하지 않다면, 충분해질 때까지 선언을 미뤄라.
```java
// Bad Case
void calculate() {
    int result; // 선언만 해두고 바로 안 씀 → 가독성 저하

    // ... 다른 코드들 ...

    result = 3 * 7; // 실제로는 여기서만 필요
    System.out.println("결과: " + result);
}

```
```java
// Good Case
void calculate() {
    int result = 3 * 7;  // 선언과 동시에 초기화
    System.out.println("결과: " + result);
}

```

#### 3. 메서드를 작게 유지하고 한 가지기능에 집중시켜라
한 메서드에서 여러 가지 기능을 처리한다면, 지역변수가 다른 기능을 수행하는 부분에서 잘못 사용될 가능성이 높다.
따라서 메서드를 기능별로 쪼개고, 위와 같은 가능성을 없애라.
```java
// Bad Case
void handleRequest(String input) {
    // 전처리 로직
    String data = input.trim();

    // 검증 로직
    boolean valid = data.length() > 3;
    if (!valid) {
        System.out.println("잘못된 입력");
        return;
    }

    // 데이터 저장 로직 (여기서 data를 수정할 수도 있어 혼동)
    data = data.toUpperCase();
    saveToDatabase(data);

    // 응답 생성 로직
    String response = "처리 완료: " + data;
    System.out.println(response);
}

```
```java
// Good Case
void handleRequest(String input) {
    String data = preprocess(input);
    if (!validate(data)) {
        System.out.println("잘못된 입력");
        return;
    }
    String saved = save(data);
    respond(saved);
}

private String preprocess(String input) {
    return input.trim();
}

private boolean validate(String data) {
    return data.length() > 3;
}

private String save(String data) {
    String processed = data.toUpperCase();
    saveToDatabase(processed);
    return processed;
}

private void respond(String result) {
    String response = "처리 완료: " + result;
    System.out.println(response);
}

```

## 예시 : 반복문
컬렉션이나 배열 순회를 위해서 `while`, `전통적인 for문`, `반복자(iterater)`, `향상된 for문(for-each)`을 사용할 수 있다. 

#### while vs 전통적인 for문
반복 변수 (loop variable) 범위가 최소화되는 for문이 낫다.
```java
public class LoopExample1 {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("철수", "영희", "민수");

        // Bad : while문 (반복 변수 i가 메서드 블록 전체에서 살아있음)
        int i = 0; // while 밖에 변수가 선언되어 스코프가 넓음
        while (i < names.size()) {
            System.out.println(names.get(i));
            i++;
        }
        int j = 0;
        while (j < names.size()) {
            System.out.println(names.get(i)); // 오타! j가 아니라 i를 사용
            j++;
        }

        // Good :  전통적인 for문 (k의 범위가 for 블록 안으로 제한됨)
        for (int k = 0; k < names.size(); k++) {
            System.out.println(names.get(k));
        }
        // 여기서는 k를 더 이상 접근할 수 없음 → 스코프 최소화 성공
        for (int k = 0; k < names.size(); k++) { // 다시 k를 선언해도 무방
            System.out.println(names.get(k));
        }
    }
}

```


#### 전통적인 for문 vs 향상된 for문
컬렉션/배열을 단순 순회할 때는 for-each가 더 직관적이고 오류가 적다.

```java
public class LoopExample2 {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("철수", "영희", "민수");

        // Bad :  전통적인 for문 (인덱스를 직접 다루므로 오류 가능성 ↑)
//        for (int i = 0; i <= names.size(); i++) {
        for (int i = 0; i < names.size(); i++) {
            String name = names.get(i);
            System.out.println(name);
        }

        // Good : 향상된 for문 (인덱스 관리 필요 X, 코드 간결, 가독성 ↑)
        for (String name : names) {
            System.out.println(name);
        }
    }
}

```
