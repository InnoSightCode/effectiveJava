# 리플렉션 API 
런타임에 클래스를 들여다보고 조작할 수 있는 자바 표준 API 기능<BR>
런타임에 JVM 내부의 Metaspace영역에 접근하여 메타데이터(클래스 구조 정보)꺼내와 사용한다.<BR>
https://ahnyezi.notion.site/Reflection-1ceb625ef6f680209a41d2f00e09798f
<BR><BR>

# 아이템 65. 리플렉션보다는 인터페이스를 사용하라
리플렉션 기능(java.lang.reflect)을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.<BR>
Class 객체가 주어지면 그 클래스의 생성자, 메서드, 필드에 해당하는 Constructor, Method, Field 인스턴스를 가져올 수 있다.<BR>
이 인스턴스들로는 그 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등을 가져올 수 있다.<BR>

```java
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;

class Person {
    private String name;
    private int age;

    public Person() {
        this("이름없음", 0);
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void sayHello() {
        System.out.println("안녕하세요, 제 이름은 " + name + "이고, 나이는 " + age + "살입니다.");
    }

    private void secretMethod() {
        System.out.println("비밀 메서드 실행!");
    }
}

public class ReflectionExample {
    public static void main(String[] args) throws Exception {
        // 1. 클래스 객체(Class) 얻기
        Class<?> clazz = Person.class;

        // 2. 클래스 이름
        System.out.println("클래스 이름: " + clazz.getName());

        // 3. 생성자 정보
        Constructor<?>[] constructors = clazz.getConstructors();
        System.out.println("\n생성자 목록:");
        Arrays.stream(constructors).forEach(c -> System.out.println(" " + c));

        // 4. 메서드 정보
        Method[] methods = clazz.getDeclaredMethods();
        System.out.println("\n메서드 목록:");
        Arrays.stream(methods).forEach(m -> System.out.println(" " + m));

        // 5. 필드 정보
        Field[] fields = clazz.getDeclaredFields();
        System.out.println("\n필드 목록:");
        Arrays.stream(fields).forEach(f -> System.out.println(" " + f));

        // 6. 리플렉션으로 객체 생성
        Constructor<?> cons = clazz.getConstructor(String.class, int.class);
        Object person = cons.newInstance("철수", 20);

        // 7. 리플렉션으로 메서드 호출
        Method sayHello = clazz.getMethod("sayHello");
        sayHello.invoke(person);

        // 8. private 메서드도 접근 가능 (주의!)
        Method secret = clazz.getDeclaredMethod("secretMethod");
        secret.setAccessible(true); // private 접근 허용
        secret.invoke(person);
    }
}

```

```text
클래스 이름: Person

생성자 목록:
 public Person(java.lang.String,int)
 public Person()

메서드 목록:
 public void Person.sayHello()
 private void Person.secretMethod()

필드 목록:
 private java.lang.String Person.name
 private int Person.age

안녕하세요, 제 이름은 철수이고, 나이는 20살입니다.
비밀 메서드 실행!

```
<BR>

## 리플렉션의 단점
위에서 본 바와 같이 강력한 기능을 가지고 있지만, 단점도 있다.

#### 1. 컴파일타임 타입 검사가 주는 이점을 누릴 수 없다 (런타임 오류가 발생)
```java
// 일반적인 코드
Person p = new Person("철수", 20);
p.sayHello();  // 컴파일 시점에 Person에 sayHello() 메서드가 있는지 검사됨

// 리플렉션 사용
Class<?> clazz = Class.forName("Person");
Object obj = clazz.getConstructor(String.class, int.class).newInstance("철수", 20);

Method method = clazz.getMethod("sayHello");
method.invoke(obj);  // 런타임에 실행
```
- 리플렉션을 사용한다면? 컴파일 시점에는 Person 클래스가 있는지, sayHello 메서드가 있는지 알 수 없음
- 오타를 내도 컴파일은 통과하고, 실제 실행할 때 `NoSuchMethodException` 같은 런타임 에러가 발생

#### 2. 코드가 지저분해지고 장황해진다
```java
// 일반적인 코드
Person p = new Person("철수", 20);
p.sayHello();  // 컴파일 시점에 Person에 sayHello() 메서드가 있는지 검사됨

// 리플렉션 사용
Class<?> clazz = Class.forName("Person");
Object obj = clazz.getConstructor(String.class, int.class).newInstance("철수", 20);

Method method = clazz.getMethod("sayHello");
method.invoke(obj);  // 런타임에 실행
```
- 일반코드로 작성하면 2줄로 끝날 로직을 리플렉션을 이용하면 장황하게 작성해야 하고 가독성도 떨어진다.

#### 3. 성능이 떨어진다
- 일반적인 메서드 호출방식은 자주 실행되면 JIT 최적화를 통해 빠르게 실행 가능
- 하지만 리플렉션은 JIT 최적화가 어렵거나 불가능
    - 리플렉션은 Method.invoke() 같은 공통 API를 거침
        - 1) 전달된 매개변수 개수/타입 체크
        - 2) 접근 제한자 확인 (private이면 setAccessible 여부 확인)
        - 3) 필요하다면 boxing/unboxing 처리
    - 이러한 과정이 리플렉션 실행 시마다 반복됨
```java
import java.lang.reflect.Method;

public class ReflectionPerformance {
    public static void main(String[] args) throws Exception {
        Person p = new Person("철수");

        // 1. sayHello 메서드 직접 호출
        long start1 = System.nanoTime();
        for (int i = 0; i < 1_000_000; i++) {
            p.sayHello();
        }
        long end1 = System.nanoTime();
        System.out.println("직접 호출: " + (end1 - start1)/1_000_000 + " ms");

        // 2. sayHello 메서드 리플렉션으로 호출
        Method method = Person.class.getMethod("sayHello");
        long start2 = System.nanoTime();
        for (int i = 0; i < 1_000_000; i++) {
            method.invoke(p);
        }
        long end2 = System.nanoTime();
        System.out.println("리플렉션 호출: " + (end2 - start2)/1_000_000 + " ms");
    }
}

class Person {
    private String name;
    public Person(String name) { this.name = name; }
    public void sayHello() { /* 간단한 메서드 */ }
}
```
<BR>

## 리플렉션의 적절한 사용법
위에서 본 바와 같이 여러 단점을 가지고 있기 때문에, 아주 제한된 형태로만 사용해야 리플렉션의 단점을 피하고 이점만 취할 수 있다.<BR>
- 리플렉션은 최소한으로 사용 -> 인스턴스 생성까지만
- 객체를 반든 후에는 일반 자바 코드처럼 인터페이스나 부모 타입으로 다루자!
- 이렇게 하면 리플렉션의 단점을 피하면서 이점만 취할 수 있음

#### 리플렉션 사용 Bad Case
```java
class Dog {
    public void speak() { System.out.println("멍멍"); }
}

public class BadReflection {
    public static void main(String[] args) throws Exception {
        // 클래스 이름 문자열로 동적 로딩
        Class<?> clazz = Class.forName("Dog");
        Object obj = clazz.getDeclaredConstructor().newInstance();

        // 메서드 실행도 전부 리플렉션으로…
        Method method = clazz.getMethod("speak");
        method.invoke(obj);  // 타입 안전성 없음
    }
}
```
- 만약 `clazz.getMethod("speek")`로 오타내면? 컴파일은 되지만 런타임 에러
- 코드도 지저분하고 가독성 떨어짐
- method.invoke로 인해 JIT 컴파일 최적화 못함

#### 리플렉션 사용 Good Case
```java
interface Animal {
    void speak();
}

class Dog implements Animal {
    public void speak() { System.out.println("멍멍"); }
}

public class GoodReflection {
    public static void main(String[] args) throws Exception {
        // 1. 리플렉션은 "인스턴스 생성"에만 사용
        Class<?> clazz = Class.forName("Dog");
        Animal animal = (Animal) clazz.getDeclaredConstructor().newInstance();

        // 2. 이후에는 일반 인터페이스 호출 (리플렉션 X)
        animal.speak();  // 컴파일 타임 타입 체크
    }
}
```
- 리플렉션은 newinstance() 시점까지만 사용
- 이후에는 Animal 인터페이스로 참조 -> 일반 메서드 호출처럼 안전하고 빠름
- 가독성도 좋고, JIT 최적화도 가능
<BR>

# LETS 코드 예시

#### sftp 서버의 EDI 파일을 읽어 java 객체로 역직렬화
```java
    try (InputStream unmarshalStream = new ByteArrayInputStream(fileBytes)) {
        JAXBContext jaxbContext = JAXBContext.newInstance(CNTINF.class); // 현재 처리하는 EDI문서의 class 메타데이터가 필요
//        JAXBContext jaxbContext = JAXBContext.newInstance(CGAINF.class);
//        JAXBContext jaxbContext = JAXBContext.newInstance(ACKANS.class);
        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
        SdsEdiType dataObject = (CNTINF.class) unmarshaller.unmarshal(unmarshalStream);
//        SdsEdiType dataObject = (CGAINF.class) unmarshaller.unmarshal(unmarshalStream);
//        SdsEdiType dataObject = (ACKANS.class) unmarshaller.unmarshal(unmarshalStream);
        sdsEdiTypeContext.saveReceivedData(dataObject);
```

#### String 타입의 클래스 이름으로부터 Class 메타데이터를 조회 (리플렉션 사용)

```java
    @Transactional
    public void receiveData(String messageTypeId) {
        Assert.notNull(messageTypeId, AssertMessageUtils.getNotNull("messageTypeId"));

        Class<? extends SdsEdiType> messageType = null;
        try {
            messageType = (Class<? extends SdsEdiType>) Class.forName(messageTypeId);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }        

        receiveData(messageTypeId, messageType);
    }
```
```java
package java.lang;
public final class Class<T> implements java.io.Serializable ...{
    @CallerSensitive
    public static Class<?> forName(String className)
                throws ClassNotFoundException {
        Class<?> caller = Reflection.getCallerClass();
        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
    }
```
- 클래스 로딩 비용: Class.forName은 클래스 이름을 기반으로 클래스를 로드한다.
  - 이 과정에서 클래스가 아직 로드되지 않았다면, JVM은 해당 클래스를 로드하고 초기화해야 한다. 이 과정은 비교적 비용이 많이 들 수 있다. 
  - 특히, 클래스 로딩은 클래스 로더에 의해 수행되며, 클래스 경로를 탐색하는 과정이 포함될 수 있다.
- 동적 로딩: Class.forName은 런타임에 클래스를 동적으로 로드한다. 
  - 이는 정적으로 컴파일된 코드와 달리, 컴파일 타임에 클래스의 존재 여부를 확인할 수 없기 때문에, JIT 컴파일러가 최적화할 수 있는 정보가 제한적이다.
- 예외 처리: Class.forName은 클래스가 존재하지 않을 경우 ClassNotFoundException을 던질 수 있다. 
  - 이러한 예외 처리는 추가적인 성능 오버헤드를 발생시킬 수 있다.
- 리플렉션의 일반적인 오버헤드: 리플렉션을 사용하여 클래스 정보를 조회하거나 조작하는 것은 일반적인 메서드 호출보다 느리다. 
  - 이는 리플렉션이 런타임에 메타데이터를 조회하고, 이를 기반으로 작업을 수행하기 때문이다.

#### String 타입의 클래스 이름으로부터 Class 메타데이터를 조회 (static 변수 활용)

<img width="921" height="788" alt="Image" src="https://github.com/user-attachments/assets/20ab2c5a-9a5a-4f75-825b-c613db544fa8" />

```java
    @Transactional
    public void receiveData(String messageTypeId) {
        Assert.notNull(messageTypeId, AssertMessageUtils.getNotNull("messageTypeId"));

        Class<? extends SdsEdiType> messageType = sdsEdiTypeContext.getMessageTypeClass(messageTypeId);

        receiveData(messageTypeId, messageType);
    }
```
- 필요한 정보를 STATIC 변수로 만들어서, 리플렉션의 Class.forName(String className)을 대신하도록 선언