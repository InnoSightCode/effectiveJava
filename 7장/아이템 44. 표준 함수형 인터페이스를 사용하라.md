# 아이템 44. 표준 함수형 인터페이스를 사용하라

## 🐳 표준 함수형 인터페이스

### 🦭 설명

- java8부터 `java.util.function` 패키지에서 제공하는 인터페이스
- 람다 표현식과 함께 함수형 프로그래밍이 가능

### 🦭 필요한 이유

- java가 람다를 지원하면서 API 설계에서 함수 객체를 인수로 받는 패턴이 많아짐

⇒ 함수를 매개변수로 전달할 때 함수형 인터페이스 사용

**😶‍🌫️ java7**

```java
List<String> list = Arrays.asList("b", "a", "c");

Collections.sort(list, new Comparator<String>() {
    @Override
    public int compare(String s1, String s2) {
        return s1.compareTo(s2);
    }
});
```

**😶‍🌫️ java8**

```java
List<String> list = Arrays.asList("b", "a", "c");

list.sort((s1, s2) -> s1.compareTo(s2));
```

- **매개변수로 함수 자체를 넘기려고 하면 람다가 없을 때는 아예 익명 클래스를 정의한 후에 그 안에다가 메소드를 정의했어야 함**
    
    ⇒ 번거로우니 이런 구조 자체가 잘 안 쓰임
    
- **람다가 등장한 후에는 함수 자체를 넘기는 게 가능해졌기 때문에 이런 구조가 많아지기 시작함**

### ☀️ 함수형 프로그래밍

- 함수를 값처럼 사용 가능(변수, 매개변수, 리턴값)
- 순수 함수 : 입력값이 같으면 출력값도 항상 같음
- 불변성: 상태나 데이터를 변경하지 않고 새로운 값만 반환
- 선언형 스타일: `how` 보다 `what` 을 기술

**☑️ Thread라는 객체를 만들 때 매개 변수로 함수를 전달하고 싶은 상황**

**🍪 java8 이전**

```java
// Java 8 이전: Runnable 예시
new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello");
    }
}).start();
```

**🍪 java8 이후**

```java
// Java 8 이후
new Thread(() -> System.out.println("Hello")).start();
```

## ☀️ 예시 - `forEach`

- `forEach` 시그니처를 보면 Consumer 인터페이스를 인수로 받는다
    - 즉, 인수를 활용(consume)해서 내부 동작을 하지만 반환값은 없음

```java
default void forEach(Consumer<? super T> action)

....

List<String> list = Arrays.asList("A", "B", "C");

list.forEach(s -> System.out.println(s)); // 반환값 없음
```

## 🐳  구현보다 표준 함수형 인터페이스 사용을 권장하는 이유

- 개념의 개수가 줄어들어 API가 단순해짐
- 유용한 디폴트 메서드를 많이 제공해서 다른 코드와 상호 운용성도 좋음

## 🐳 기본 함수형 인터페이스(총 43개)

| 인터페이스 | 기능 | 시그니처 예시 | 사용 예 |
| --- | --- | --- | --- |
| `UnaryOperator<T>` | 같은 타입 → 같은 타입 | `T apply(T t)` | `String::toLowerCase` |
| `BinaryOperator<T>` | 같은 타입 2개 → 같은 타입 | `T apply(T t1, T t2)` | `BigInteger::add` |
| `Predicate<T>` | T → boolean | `boolean test(T t)` | `Collection::isEmpty` |
| `Function<T,R>` | T → R | `R apply(T t)` | `Arrays::asList` |
| `Supplier<T>` | () → T | `T get()` | `Instant::now` |
| `Consumer<T>` | T → void | `void accept(T t)` | `System.out::println` |
- `Predicate` : 단일 인수를 받아 boolean을 반환하는 껍데기
- `Function` : 인수와 반환 타입이 다른 껍데기
- `Supplier` : 인수 없이 반환값만 있는 껍데기 → 리턴을 공급(supply)만
- `Consumer` : 인수를 받고 반환값은 없는 껍데기 → 받은 인수를 소비(consume)하기만 함

🌟**(cf) 사용 예 : 사용 예에 있는 메소드들의 매개변수로 각 함수형 인터페이스를 쓸 수 있음**

```java
import java.util.function.Supplier;

public class Test {
    public static void main(String[] args) {
        Supplier<String> func = () -> "Hello, World!";
        System.out.println(func.get()); // Hello, World! 출력
    }
}
```

## 🐳 직접 인터페이스를 만들어야 하는 경우

- 필요한 게 없을 때
- 자주 쓰임, 이름이 용도를 잘 설명함, 반드시 지켜야 할 규약이 있음, 유용한 디폴트 메서드를 많이 담고 있음

⇒ `인터페이스` 를 만드는 것이기 때문에 주의에서 설계해야 함!

**⇒ `@FunctionalInterface` 어노테이션을 달아서 함수형 인터페이스라는 의도를 명확하게 하고(얘는 그냥 매개변수로 전달하기 위한 거에요), 실수로 메서드가 추가되지 않도록 한다**